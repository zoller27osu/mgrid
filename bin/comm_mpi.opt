       !        
       !        Cray Inc. Decompilation
       !        Notice - This output is provided for information only.
       !        
       !        Cray Inc. reserves the right to change the format of this
       !        information at any time and does not guarantee the
       !        readability or accuracy of this information.
       !        
       !        This information may not be compilable and corresponds to
       !        the internal representation of the program during the
       !        optimization phase of the compilation process.
       !        
       !        Source                :  comm_mpi.F
       !        File                  :  /mnt/a/u/sciteam/zoller/mgrid/bin/comm_mpi.opt
       !        Network               :  Gemini interconnect
       !        Target                :  X86 :: interlagos, avx, xop, fma, pic
       !        
    7.       
    7.       subroutine init_proc
   13.       call mpi_init( ierr )
   15.       call mpi_comm_size( 1140850688, np, ierr )
   16.       call mpi_comm_rank( 1140850688, nid, ierr )
   23.       wdsize = 8
   24.       if ( nid == 0 ) then
   24.          _fwrite( _clist( 0, 0, 3, 6, Null_Arg, Null_Arg, Null_Arg, Null_Arg, Null_Arg, Null_Arg, Null_Arg, Null_Arg, 0, Null_Arg, Null_Arg, Null_Arg, Null_Arg, Null_Arg, Null_Arg, Null_Arg, Null_Arg, Null_Arg, Null_Arg ), _iolist( _iotype( 'Wdsize = 8!', 0x800600000000L ) ) )
   24.       endif
   27.       mgreal = 1275070495
   29.       if ( nid == 0 ) then
   30.          wtick = mpi_wtick
   31.          _fwrite( _clist( 0, 0, 3, 6, Null_Arg, Null_Arg, Null_Arg, Null_Arg, Null_Arg, Null_Arg, Null_Arg, Null_Arg, 0, Null_Arg, Null_Arg, Null_Arg, Null_Arg, Null_Arg, Null_Arg, Null_Arg, Null_Arg, Null_Arg, Null_Arg ), _iolist( _iotype( 'MPI_Wtick: ', 0x800600000000L ), _iotype( wtick, 0x4010300000000L ) ) )
   31.       endif
   40.       lrtype = 0
   41.       udtype = 0
   42.       fbtype = 0
   45.       return
   45.       end
   45.       
   47.       
   47.       subroutine make_3d_types( mx1, my1, mz1, ioldtype, enable_fbtype )
   52.       t$5 = my1 * mz1
   52.       call mpi_type_vector( t$5, 1, mx1, ioldtype, lrtype, ierr )
   53.       call mpi_type_commit( lrtype, ierr )
   54.       t$5 = my1 * mx1
   54.       call mpi_type_vector( mz1, mx1, t$5, ioldtype, udtype, ierr )
   55.       call mpi_type_commit( udtype, ierr )
   56.       if ( enable_fbtype ) then
   57.          t$5 = my1 * mx1
   57.          call mpi_type_contiguous( t$5, ioldtype, fbtype, ierr )
   58.          call mpi_type_commit( fbtype, ierr )
   58.       endif
   63.       return
   63.       end
   63.       
   65.       
   65.       subroutine erase_3d_types
   68.       if ( udtype /= 0 ) then
   69.          call mpi_type_free( lrtype, ierr )
   70.          call mpi_type_free( udtype, ierr )
   70.       endif
   72.       if ( fbtype /= 0 ) then
   72.          call mpi_type_free( fbtype, ierr )
   72.       endif
   73.       lrtype = 0
   74.       udtype = 0
   75.       fbtype = 0
   78.       return
   78.       end
   78.       
   80.       
   80.       subroutine gop( x, w, op, n )
   80.       t$8 = n
   88.       t$9 = _zla( 0, n )
   91.       if (  _substr(op,1,3) == '+  ' ) then
   92.          call mpi_allreduce( x(1), w(1), n, mgreal, 1476395011, 1140850688, ierr )
   93.       else if (  _substr(op,1,3) == 'M  ' ) then
   94.          call mpi_allreduce( x(1), w(1), n, mgreal, 1476395009, 1140850688, ierr )
   94.       else if (  _substr(op,1,3) == 'm  ' ) then
   96.          call mpi_allreduce( x(1), w(1), n, mgreal, 1476395010, 1140850688, ierr )
   96.       else if (  _substr(op,1,3) == '*  ' ) then
   98.          call mpi_allreduce( x(1), w(1), n, mgreal, 1476395012, 1140850688, ierr )
   98.       else
  100.          _fwrite( _clist( 0, 0, 3, 6, Null_Arg, Null_Arg, Null_Arg, Null_Arg, Null_Arg, Null_Arg, Null_Arg, Null_Arg, 0, Null_Arg, Null_Arg, Null_Arg, Null_Arg, Null_Arg, Null_Arg, Null_Arg, Null_Arg, Null_Arg, Null_Arg ), _iolist( _iotype( nid, 0x2000200000000L ), _iotype( ' OP ', 0x800600000000L ), _iotype(  _substr(op,1,3), 0x800600000000L ), _iotype( ' not supported.  ABORT in GOP.', 0x800600000000L ) ) )
  101.          call exitt
  101.       endif
  104.       call copy( x(1), w(1), n )
  107.       return
  107.       end
  107.       
  109.       
  109.       subroutine csend( msgtag, buf, len, jnid, jpid )
  115.       _mpi_send( loc( buf(1) ), loc( len ), _adrcon( 1275068685 ), loc( jnid ), loc( msgtag ), _adrcon( 1140850688 ), loc( ierr ) )
  118.       return
  118.       end
  118.       
  120.       
  120.       subroutine crecv( msgtag, buf, lenm )
  127.       len = lenm
  128.       jnid = -2
  130.       _mpi_recv( loc( buf(1) ), loc( len ), _adrcon( 1275068685 ), loc( jnid ), loc( msgtag ), _adrcon( 1140850688 ), loc( status(1) ), loc( ierr ) )
  139.       return
  139.       end
  139.       
  141.       
  141.       subroutine gsync
  147.       call mpi_barrier( 1140850688, ierr )
  151.       return
  151.       end
  151.       
  153.       
  153.       subroutine msgwait( imsg )
  160.       if ( imsg /= 738197504 ) then
  163.          call mpi_wait( imsg, status(1), ierr )
  163.       endif
  166.       return
  166.       end
  166.       
  168.       
  168.       subroutine csend0( msgtag, buf, len, jnid, jpid )
  175.       if ( msgtag >= 0 ) then
  176.          if ( jnid >= 0 ) then
  177.             if ( jnid < np ) then
  179.                _mpi_send( loc( buf(1) ), loc( len ), _adrcon( 1275068685 ), loc( jnid ), loc( msgtag ), _adrcon( 1140850688 ), loc( ierr ) )
  179.             endif
  179.          endif
  179.       endif
  182.       return
  182.       end
  182.       
  184.       
  184.       subroutine exitt
  187.       call erase_3d_types
  189.       call gsync
  190.       call mpi_finalize( ierr )
  191.       t$15 = 0
  191.       call exit( t$15 )
  194.       return
  194.       end
  194.       
  196.       
  196.       subroutine bcast( buf, len )
  203.       call mpi_bcast( buf(1), len, 1275068685, 0, 1140850688, ierr )
  206.       return
  206.       end
  206.       
  208.       
  208.       integer*4
  208.       function isend( msgtag, x, len, jnid, jpid )
  218.       call mpi_isend( x, len, 1275068685, jnid, msgtag, 1140850688, imsg, ierr )
  224.       isend = imsg
  224.       return
  224.       end
  224.       
  226.       
  226.       integer*4
  226.       function irecv( msgtag, x, len )
  236.       call mpi_irecv( x, len, 1275068685, -2, msgtag, 1140850688, imsg, ierr )
  242.       irecv = imsg
  242.       return
  242.       end
  242.       
  244.       
  244.       integer*4
  244.       function irecv0( msgtag, x, len )
  253.       if ( msgtag < 0 ) then
  254.          n = len / wdsize
  255.          call rzero( x, n )
  256.          $irecv0_S0 = 738197504
  256.       else
  258.          call mpi_irecv( x, len, 1275068685, -2, msgtag, 1140850688, imsg, ierr )
  260.          $irecv0_S0 = imsg
  260.       endif
  266.       irecv0 = $irecv0_S0
  266.       return
  266.       end
  266.       
  269.       
  269.       subroutine csend1( msgtag, x, itype, num, jnid )
  275.       if ( msgtag >= 0 ) then
  275.          if ( jnid /= -1 ) then
  277.             _mpi_send( loc( x ), loc( num ), loc( itype ), loc( jnid ), loc( msgtag ), _adrcon( 1140850688 ), loc( ierr ) )
  277.          endif
  277.       endif
  280.       return
  280.       end
  280.       
  282.       
  282.       integer*4
  282.       function isend1( msgtag, x, itype, num, jnid )
  288.       if ( msgtag < 0 .orelse. jnid == -1 ) then
  289.          isend1 = 738197504
  289.       else
  291.          call mpi_isend( x, num, itype, jnid, msgtag, 1140850688, isend1, ierr )
  291.       endif
  296.       isend1 = isend1
  296.       return
  296.       end
  296.       
  298.       
  298.       integer*4
  298.       function irecv1( msgtag, x, itype, num )
  308.       if ( msgtag < 0 ) then
  309.          irecv1 = 738197504
  309.       else
  312.          call mpi_irecv( x, num, itype, -2, msgtag, 1140850688, irecv1, ierr )
  312.       endif
  325.       irecv1 = irecv1
  325.       return
  325.       end
  325.       
  327.       
  327.       integer*4
  327.       function irecv2( msgtag, x, itype, num, jnid )
  350.       call mpi_irecv( x, num, itype, jnid, -1, 1140850688, irecv2, ierr )
  363.       irecv2 = irecv2
  363.       return
  363.       end
  363.       
  365.       
  365.       subroutine msgwaitall( imsgs, num )
  365.       t$25 = num
  370.       t$26 = _zla( 0, num )
  382.       call mpi_waitall( num, imsgs(1), mpi_statuses_ignore(1, 1), ierr )
  403.       return
  403.       end
  403.       
  407.       
  407.       real*8
  407.       function dclock
  412.       $dclock_S0 = mpi_wtime
  421.       dclock = $dclock_S0
  421.       return
  421.       end
  421.       
  423.       
  423.       logical
  423.       function arreq( a, b, n )
  427.       $arreq_S0 = .true.
  428.       if ( n > 0 ) then
  428.          $I_L428_6 = 0
  428. !dir$ ivdep
  428.          do
  429.             if ( b(1 + $I_L428_6) /= a(1 + $I_L428_6) ) then
  430.                if ( nid == 6 ) then
  431.                   $IOitem_O0 = ( 1 + $I_L428_6 )
  431.                   $IOitem_O1 = a(1 + $I_L428_6)
  431.                   $IOitem_O2 = b(1 + $I_L428_6)
  431.                   _fwrite( _clist( 0, 0, 3, 6, Null_Arg, Null_Arg, Null_Arg, Null_Arg, Null_Arg, Null_Arg, Null_Arg, Null_Arg, 0, Null_Arg, Null_Arg, Null_Arg, Null_Arg, Null_Arg, Null_Arg, Null_Arg, Null_Arg, Null_Arg, Null_Arg ), _iolist( _iotype( 'different at', 0x800600000000L ), _iotype( $IOitem_O0, 0x2000200000000L ), _iotype( '(', 0x800600000000L ), _iotype( $IOitem_O1, 0x4000300000000L ), _iotype( 'vs', 0x800600000000L ), _iotype( $IOitem_O2, 0x4000300000000L ), _iotype( ')', 0x800600000000L ) ) )
  431.                endif
  433.                $arreq_S0 = .false.
  433.                goto 10
  433.             endif
  436.             $I_L428_6 = 1 + $I_L428_6
  436.             if ( $I_L428_6 >= n ) exit
  436.          enddo
  436.       endif
  436.    10 continue
  438.       arreq = $arreq_S0
  438.       return
  438.       end
  438.       
  440.       
  440.       logical
  440.       function mateq( a, b, mnb )
  440.       t$30 = mx
  440.       t$31 = my
  440.       t$32 = mz
  440.       t$33 = 1 + mx
  443.       t$34 = _zla( 0, 1 + mx )
  440.       t$35 = _zla( 0, 1 + mx )
  440.       t$36 = 1 + my
  443.       t$37 = _zla( 0, 1 + my )
  440.       t$38 = _zla( 0, 1 + mx ) * _zla( 0, 1 + my )
  440.       t$39 = 1 + mz
  443.       t$40 = _zla( 0, 1 + mz )
  440.       t$41 = _zla( 0, 1 + mx ) * _zla( 0, 1 + my ) * _zla( 0, 1 + mz )
  444.       $mateq_S0 = .true.
  446.       if ( mz >= 0 ) then
  446.          $I_L446_82 = 0
  446.          do
  448.             if ( mnb > 0 .orelse. ( $I_L446_82 == 0 .or. $I_L446_82 + -mz == 0 ) == 0 ) then
  449.                if ( my >= 0 ) then
  449.                   $I_L449_80 = 0
  449.                   do
  451.                      if ( mnb > 1 .orelse. ( $I_L449_80 == 0 .or. $I_L449_80 + -my == 0 ) == 0 ) then
  452.                         if ( mx < 0 ) then
  473.                            $I_L449_80 = 1 + $I_L449_80
  473.                         else if ( mnb > 2 ) then
  473.                         else if ( $I_L449_80 == 0 .or. $I_L449_80 + -my == 0 ) then
  473.                         else if ( mnb <= 0 ) then
  473.                         else if ( mnb > 1 ) then
  473.                         else if ( $I_L449_80 == 0 .or. $I_L449_80 + -my == 0 ) then
  473.                         else if ( ( $I_L446_82 == 0 .or. $I_L446_82 + -mz == 0 ) == 0 ) then
  473.                         else
  473.                         endif
  473.                      else
  473.                      endif
  473.                      if ( $I_L449_80 >= 1 + my ) exit
  473.                   enddo
  474.                   $I_L446_82 = 1 + $I_L446_82
  474.                else
  474.                endif
  474.             else
  474.             endif
  474.             if ( $I_L446_82 >= 1 + mz ) exit
  474.          enddo
  474.       endif
  478.       mateq = $mateq_S0
  478.       return
  478.       end
  478.       
  405.       
  405.       module comm_funcs
  479.       return
  479.       end
  479.       
